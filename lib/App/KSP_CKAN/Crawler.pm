package App::KSP_CKAN::Crawler;

use strict;
use warnings;
use v5.010;
use File::Find::Rule;
use File::Copy qw(copy);
use File::Temp qw(tempdir);
use File::Path qw(remove_tree mkpath);
use File::Slurp qw(read_dir);
use File::Basename qw(basename);
use App::KSP_CKAN::Tools::IA;
use App::KSP_CKAN::Metadata::Ckan;
use App::KSP_CKAN::Crawler::Schema;
use App::KSP_CKAN::Crawler::InflateNetKAN;
use Method::Signatures 20140224;
use Carp qw(croak);
use AnyEvent::ForkManager;
use AnyEvent;
use EV;
use Moo;
use namespace::clean;

# ABSTRACT: Metadata Crawler to re-inflate CKANs and Check mirror status

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::Crawler;

  my $crawler = App::KSP_CKAN::Crawler( config => $confg );
  $crawler->run;

=head1 DESCRIPTION

Webhook wrapper for NetKAN inflation on demand.

=cut

my $Ref = sub {
  croak("config isn't a 'App::KSP_CKAN::Tools::Config' object!") unless $_[0]->DOES("App::KSP_CKAN::Tools::Config");
};

has 'config'          => ( is => 'ro', required => 1, isa => $Ref );
has '_schema'         => ( is => 'rw', lazy => 1, builder => 1 );
has '_CKAN_meta'      => ( is => 'ro', lazy => 1, builder => 1 );
has '_CKAN_meta_path' => ( is => 'ro', lazy => 1, builder => 1 );
has '_output'         => ( is => 'ro', lazy => 1, builder => 1 );
has '_inflator'       => ( is => 'ro', lazy => 1, builder => 1 );
has '_ia'             => ( is => 'ro', lazy => 1, builder => 1 );
has '_inflating'      => ( is => 'rw', default => sub { 0 } );
has '_mirror_check'   => ( is => 'rw', default => sub { 0 } );

method _build__schema {
  # TODO: Build a proper config here
  return App::KSP_CKAN::Crawler::Schema->connect(
    "dbi:mysql:dbname=ksp_ckan",
    $ENV{'CKAN_DBUSER'}, 
    $ENV{'CKAN_DBPASS'},
  );
}

method _build__CKAN_meta {
  return App::KSP_CKAN::Tools::Git->new(
    remote  => $self->config->CKAN_meta,
    local   => $self->config->working,
    clean   => 1,
  );
}

method _build__inflator {
  return App::KSP_CKAN::Crawler::InflateNetKAN->new(
    config  => $self->config,
  );
}

method _build__ia {
  return App::KSP_CKAN::Tools::IA->new(
    config  => $self->config,
  );
}

method _build__CKAN_meta_path {
  return $self->config->working."/".$self->_CKAN_meta->working;
};

method update_ckan_meta {
  $self->_CKAN_meta->pull;
  my $path = $self->_CKAN_meta_path;
  my @dirs = grep { -d $path."/$_" } read_dir($path);
  $self->debug("Updating DB");
  foreach my $dir (@dirs) {
    my @ckans = File::Find::Rule->file()->name( qr/\.ckan$/ )->in( "$path/$dir" );
    foreach my $ckan (@ckans) {
      my $file = basename($ckan);
      my $result = $self->_schema->resultset('CKAN_meta')->find_or_create({
        identifier  => $dir,
        file        => $file
      });
    }
  }
}

method check_existing {
  my $path = $self->_CKAN_meta_path;
  my $ckans = $self->_schema->resultset('CKAN_meta')->search;
  $self->debug("Checking for file existence");
  while (my $ckan = $ckans->next) {
    if ( -e $path."/".$ckan->identifier."/".$ckan->file ) {
      $ckan->update( { deleted => 0 } );
    } else {
      $ckan->update( { deleted => 1 } );
    }
  }
}

method update_random_ckans($number = 20) {
  my $path = $self->_CKAN_meta_path;
  # TODO: Maybe we shouldn't store the sha1 just a bool of
  #       if one has one.
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => undef, last_checked => undef });
  $self->debug("Checking random ckans");
  foreach my $row (@rows) {
    $self->debug("Updating: ".$row->file);
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $path."/".$row->identifier."/".$row->file );
    $row->update( {
      last_checked => \'NOW()',
      download_sha1 => $ckan->download_sha1,
    } );
  }
}

method check_random_mirrored($number = 20) {
  my $path = $self->_CKAN_meta_path;

  # TODO: At some point this will return nothing, we might want to start
  #       crawling the rest to check for updates.
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => { '!=', undef }, download_sha1 => { '!=', 0 }, mirrored => undef });
  $self->debug("Checking random mirrored ckans");
  foreach my $row (@rows) {
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $path."/".$row->identifier."/".$row->file );
    $self->debug("Checking ".$ckan->mirror_item." - SHA1: ".$ckan->download_sha1) if $ckan->can_mirror;
    $row->update( {
      last_checked => \'NOW()',
      mirrored    => $self->_ia->ckan_mirrored( ckan => $ckan),
    } ) if $ckan->can_mirror;
    sleep 5; # We're crawling, lets not hit the mirror too hard.
  }
}

method inflate_random($number = 2) {
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => 0 });
  my $path = $self->_CKAN_meta_path;
  $self->_CKAN_meta->pull;
  
  my $tmp = File::Temp::tempdir();
  my @files;
  $self->debug("Inflating random ckans");
  
  foreach my $row (@rows) {
    $self->debug("Copying: ".$row->file);
    my $file = $row->identifier.".netkan";
    my $output = $tmp."/$file";
    copy($path."/".$row->identifier."/".$row->file, $output);
    push(@files, $output);
  }

  $self->_inflator->inflate(\@files);
 
  # TODO: Once commited + pushed it will cause the mirror process to take place.
  #       We should either mirror straight away and pull the commit process to be
  #       done at the end
  foreach my $row (@rows) {
    $self->debug("Consuming new metadata: ".$row->file);
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $path."/".$row->identifier."/".$row->file );
    $row->update( {
      last_checked => \'NOW()',
      download_sha1 => $ckan->download_sha1,
    } );
  }

  remove_tree($tmp);
  $self->_inflating(0);
  return;
}

method run {
  # TODO: Ponder our timings
  my $update_ckan_meta  = AE::timer 0,    3600, sub { $self->update_ckan_meta; };
  my $check_existing    = AE::timer 15,   3600, sub { $self->check_existing; };
  my $update_random     = AE::timer 30,   120,  sub { $self->update_random_ckans; };

  my $check_fork = AnyEvent::ForkManager->new(
      max_workers => 1,
      on_start    => sub { $self->_mirror_check(1) },
      on_finish   => sub { $self->_mirror_check(0) },
  );

  my $check_random = AE::timer 30, 120, sub { 
    if ($self->_mirror_check) {
       $self->debug("Skipping inflation this round");
       return;
    }

    $check_fork->start(
      cb => sub {
        $self->check_random_mirrored; 
      },
    );
  };

  my $inflate_fork = AnyEvent::ForkManager->new(
      max_workers => 1,
      on_start    => sub { $self->_mirror_check(1) },
      on_finish   => sub { $self->_mirror_check(0) },
  );

  my $inflate_random =  AE::timer 60, 120, sub {
    if ($self->_inflating) {
       $self->debug("Skipping mirror check this round");
       return;
    }

    $inflate_fork->start(
      cb => sub {
        $self->inflate_random;
      },
    );
  };
  EV::loop; 
}

with('App::KSP_CKAN::Roles::Logger');

1;
