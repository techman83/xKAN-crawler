package App::KSP_CKAN::Crawler;

use strict;
use warnings;
use v5.010;
use File::Find::Rule;
use File::Find::Age;
use File::Copy qw(copy);
use File::Temp qw(tempdir);
use File::Path qw(remove_tree mkpath);
use File::Slurp qw(read_dir);
use File::chdir;
use File::Basename qw(basename fileparse);
use App::KSP_CKAN::Tools::IA;
use App::KSP_CKAN::Metadata::Ckan;
use App::KSP_CKAN::Crawler::Schema;
use App::KSP_CKAN::Crawler::InflateNetKAN;
use App::KSP_CKAN::Crawler::MirrorCKAN;
use List::MoreUtils qw(first_index any none);
use Method::Signatures 20140224;
use Carp qw(croak);
use AnyEvent::ForkManager;
use AnyEvent;
use EV;
use Moo;
use namespace::clean;

# ABSTRACT: Metadata Crawler to re-inflate CKANs and Check mirror status

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::Crawler;

  my $crawler = App::KSP_CKAN::Crawler( config => $confg );
  $crawler->run;

=head1 DESCRIPTION

Webhook wrapper for NetKAN inflation on demand.

=cut

my $Ref = sub {
  croak("config isn't a 'App::KSP_CKAN::Tools::Config' object!") unless $_[0]->DOES("App::KSP_CKAN::Tools::Config");
};

has 'config'          => ( is => 'ro', required => 1, isa => $Ref );
has '_schema'         => ( is => 'rw', lazy => 1, builder => 1 );
has '_CKAN_meta'      => ( is => 'ro', lazy => 1, builder => 1 );
has '_CKAN_meta_path' => ( is => 'ro', lazy => 1, builder => 1 );
has '_output'         => ( is => 'ro', lazy => 1, builder => 1 );
has '_ia'             => ( is => 'ro', lazy => 1, builder => 1 );
has '_inflating'      => ( is => 'rw', default => sub { 0 } );
has '_mirror_check'   => ( is => 'rw', default => sub { 0 } );
has '_random_mirror'  => ( is => 'rw', default => sub { 0 } );

method _build__schema {
  # TODO: Build a proper config here
  return App::KSP_CKAN::Crawler::Schema->connect(
    "dbi:mysql:dbname=ksp_ckan",
    $ENV{'CKAN_DBUSER'}, 
    $ENV{'CKAN_DBPASS'},
  );
}

method _build__CKAN_meta {
  return App::KSP_CKAN::Tools::Git->new(
    remote  => $self->config->CKAN_meta,
    local   => $self->config->working,
    clean   => 1,
  );
}

method _build__ia {
  return App::KSP_CKAN::Tools::IA->new(
    config  => $self->config,
  );
}

method _build__CKAN_meta_path {
  return $self->config->working."/".$self->_CKAN_meta->working;
};

method update_ckan_meta {
  $self->_CKAN_meta->pull;
  my $path = $self->_CKAN_meta_path;
  my @dirs = grep { -d $path."/$_" } read_dir($path);
  $self->debug("Updating DB");
  foreach my $dir (@dirs) {
    my @ckans = File::Find::Rule->file()->name( qr/\.ckan$/ )->in( "$path/$dir" );
    foreach my $ckan (@ckans) {
      my $file = basename($ckan);
      my $result = $self->_schema->resultset('CKAN_meta')->find_or_create({
        identifier  => $dir,
        file        => $file
      });
    }
  }
}

method check_existing {
  my $path = $self->_CKAN_meta_path;
  my $ckans = $self->_schema->resultset('CKAN_meta')->search;
  $self->debug("Checking for file existence");
  while (my $ckan = $ckans->next) {
    if ( -e $path."/".$ckan->identifier."/".$ckan->file ) {
      $ckan->update( { deleted => 0 } );
    } else {
      $ckan->update( { deleted => 1 } );
    }
  }
}

method update_random_ckans($number = 20) {
  my $path = $self->_CKAN_meta_path;
  # TODO: Maybe we shouldn't store the sha1 just a bool of
  #       if one has one.
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => undef, last_checked => undef });
  $self->debug("Checking random ckans");
  foreach my $row (@rows) {
    $self->debug("Updating: ".$row->file);
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $path."/".$row->identifier."/".$row->file );
    $row->update( {
      last_checked => \'NOW()',
      download_sha1 => $ckan->download_sha1,
    } );
  }
}

method check_random_mirrored($number = 20) {
  my $path = $self->_CKAN_meta_path;

  # TODO: At some point this will return nothing, we might want to start
  #       crawling the rest to check for updates.
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => { '!=', undef }, download_sha1 => { '!=', 0 }, mirrored => undef });
  $self->debug("Checking random mirrored ckans");
  foreach my $row (@rows) {
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $path."/".$row->identifier."/".$row->file );
    $self->info("Checking mirror for: ".$ckan->mirror_item." - SHA1: ".$ckan->download_sha1) if $ckan->can_mirror;
    my $mirrored = $self->_ia->ckan_mirrored( ckan => $ckan);
    $row->update( {
      last_checked => \'NOW()',
      mirrored     => $mirrored,
      can_mirror   => $ckan->can_mirror,
    } ) if $ckan->can_mirror;
    sleep 1; # We're crawling, lets not hit the mirror too hard.
  }
}

method mirror_random($number = 2) {
  my $path = $self->_CKAN_meta_path;
  my $cache = File::Temp::tempdir();

  # TODO: If our file is already mirrored we may try continously
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, mirrored => 0, can_mirror => 1 });
  $self->debug("Mirror random ckans");
  my $mirror = App::KSP_CKAN::Crawler::MirrorCKAN->new(
    config    => $self->config,
    cache     => $cache,
    CKAN_meta => $self->_CKAN_meta,
  );
  foreach my $row (@rows) {
    my $ckan_file = $path."/".$row->identifier."/".$row->file;
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $ckan_file );
    $self->info("Mirroring: ".$ckan->mirror_item." - SHA1: ".$ckan->download_sha1);
    $mirror->mirror($ckan_file);
    sleep 1; # takes a moment to appear on the archive.:
    my $mirrored = $self->_ia->ckan_mirrored( ckan => $ckan);
    $row->update( {
      last_checked => \'NOW()',
      mirrored     => $mirrored,
    } );
    sleep 1; # We're crawling, lets not hit the mirror too hard.
  }
  
  $self->debug("Temp Path: ".$cache);
  remove_tree($cache) or $self->fatal("Couldn't remove $cache, $!");
}

method _check_output($path, $file) {
  my $newfile = File::Find::Age->in($path)->[-1]->{file};
  return basename($newfile);
}

method _remove_file($original_file, $new_file) {
  my($basename, $dir) = fileparse($original_file);
  $self->info("Removing '".$basename."' from metadata");
  local $CWD = $dir;
  unlink($basename) or $self->fatal("Unable to remove $basename: $!");
  $self->_CKAN_meta->commit(
    file    => $original_file,
    message => "'".$basename."' replaced by '".$new_file,
  ) unless $self->is_debug;
  return;
}

# TODO: Oh gosh this is unwieldy, could do with a refactor.
method inflate_random($number = 2) {
  my @rows = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => 0 });
  my $path = $self->_CKAN_meta_path;
  $self->_CKAN_meta->_clean; # TODO: expose this method properly
  $self->_CKAN_meta->pull;

  my $tmp = File::Temp::tempdir();
  $self->debug("Inflating random ckans");

  # Copy our CKANs to NetKANs
  my @files;
  foreach my $row (@rows) {
    $self->info("Copying '".$row->file."' for inflation");
    my $file = $row->identifier.".netkan";
    my $output = $tmp."/$file";
    copy($path."/".$row->identifier."/".$row->file, $output);
    push(@files, $output);
  }

  my $inflator = App::KSP_CKAN::Crawler::InflateNetKAN->new(
    config    => $self->config,
    CKAN_meta => $self->_CKAN_meta,
  );
 
  # Inflate our NetKANs 
  my @successes = $inflator->inflate( 
    files => \@files,
    cache => $tmp."/cache",
  );

  my $mirror = App::KSP_CKAN::Crawler::MirrorCKAN->new(
    config    => $self->config,
    CKAN_meta => $self->_CKAN_meta,
    cache     => $tmp."/cache",
  );
  foreach my $success (@successes) {
    # Check we inflated the file without errors, then consume the metadata
    $self->debug("Checking inflated file: ".$success);
    my $index = first_index { $_->identifier eq basename($success,".netkan") } @rows;
    my $row = $rows[$index];
    $self->info("Consuming new metadata: ".$row->file);
    my $out_path = $path."/".$row->identifier;
   
    # A lot of metadata was handcrafted, potentially with incorrect names.
    my $original_file = $out_path."/".$row->file;
    my $new_file = $self->_check_output( $out_path, $original_file );
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $out_path."/".$new_file );
    $row->update( {
      last_checked  => \'NOW()',
      download_sha1 => $ckan->download_sha1,
      failed        => 0,
    } );
   
    # lets remove the files we replace.
    if ( $row->file ne $new_file ) {
      $self->info($new_file." didn't match original filename of ".$row->file);
      $self->_remove_file($original_file, $new_file);
      $row->update( {
        file => $new_file,
      }) unless $self->is_debug;
    } else {
      $self->debug($new_file." matched original filename of ".$row->file);
    }

    # Mirror this puppy!
    $mirror->mirror($out_path."/".$new_file);
  }

  # Check our failed files
  foreach my $file (@files) {
    if ( none { basename($_) eq basename($file) } @successes ) {
      my $identifier = basename($file, ".netkan");
      my $status = $inflator->_status->get_status($identifier);
      my $index = first_index { $_->identifier eq $identifier } @rows;
      my $row = $rows[$index];
      $self->warn($row->file." failed to inflate");
      $row->update( {
        last_checked  => \'NOW()',
        last_error    => $status->last_error,
        failed        => 1,
      } );
    }
  }

  # give the mirror a chance for the files to appear
  # save triggering the webhooks to re-upload
  # TODO: We could use the api to check here
  sleep 30; 

  $inflator->push_ckan_meta unless $self->is_debug;
  $self->debug("Temp Path: ".$tmp);
  remove_tree($tmp) or $self->fatal("Couldn't remove $tmp, $!");
  return;
}

method run {
  # TODO: Ponder our timings
  my $update_ckan_meta  = AE::timer 0,    3600, sub { $self->update_ckan_meta; };
  my $check_existing    = AE::timer 60,   3600, sub { $self->check_existing; };
  my $update_random     = AE::timer 30,   120,  sub { $self->update_random_ckans; };

  # TODO: Could likely handle this forking more efficiently..
  my $check_fork = AnyEvent::ForkManager->new(
      max_workers => 1,
      on_start    => sub { $self->_mirror_check(1) },
      on_finish   => sub { $self->_mirror_check(0) },
  );

  my $check_random = AE::timer 0, 120, sub { 
    if ($self->_mirror_check) {
       $self->debug("Skipping mirror check this round");
       return;
    }

    $check_fork->start(
      cb => sub {
        $self->check_random_mirrored; 
      },
    );
  };

  my $inflate_fork = AnyEvent::ForkManager->new(
      max_workers => 1,
      on_start    => sub { $self->_inflating(1) },
      on_finish   => sub { $self->_inflating(0) },
  );

  my $inflate_random =  AE::timer 30, 300, sub {
    if ($self->_inflating) {
       $self->debug("Skipping inflation this round");
       return;
    }

    $inflate_fork->start(
      cb => sub {
        $self->inflate_random;
      },
    );
  };
  
  my $mirror_fork = AnyEvent::ForkManager->new(
      max_workers => 1,
      on_start    => sub { $self->_random_mirror(1) },
      on_finish   => sub { $self->_random_mirror(0) },
  );

  my $mirror_random =  AE::timer 60, 300, sub {
    if ($self->_random_mirror) {
       $self->debug("Skipping mirroring this round");
       return;
    }

    $mirror_fork->start(
      cb => sub {
        $self->mirror_random;
      },
    );
  };
 
  # TODO: We should exit gracefully at the end of a loop 
  EV::loop; 
}

with('App::KSP_CKAN::Roles::Logger');

1;
