package App::KSP_CKAN::Crawler;

use strict;
use warnings;
use v5.010;
use File::Find::Rule;
use File::Copy qw(copy);
use File::Temp qw(tempdir);
use File::Path qw(remove_tree mkpath);
use File::Slurp qw(read_dir);
use File::Basename qw(basename);
use App::KSP_CKAN::Tools::IA;
use App::KSP_CKAN::Crawler::Schema;
use App::KSP_CKAN::Crawler::InflateNetKAN;
use Method::Signatures 20140224;
use Carp qw(croak);
use AnyEvent;
use EV;
use Moo;
use namespace::clean;

# ABSTRACT: Metadata Crawler to re-inflate CKANs and Check mirror status

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::Crawler;

  my $crawler = App::KSP_CKAN::Crawler( config => $confg );
  $crawler->run;

=head1 DESCRIPTION

Webhook wrapper for NetKAN inflation on demand.

=cut

my $Ref = sub {
  croak("config isn't a 'App::KSP_CKAN::Tools::Config' object!") unless $_[0]->DOES("App::KSP_CKAN::Tools::Config");
};

has 'config'          => ( is => 'ro', required => 1, isa => $Ref );
has '_schema'         => ( is => 'rw', lazy => 1, builder => 1 );
has '_CKAN_meta'      => ( is => 'ro', lazy => 1, builder => 1 );
has '_CKAN_meta_path' => ( is => 'ro', lazy => 1, builder => 1 );
has '_output'         => ( is => 'ro', lazy => 1, builder => 1 );
has '_inflator'       => ( is => 'ro', lazy => 1, builder => 1 );
has '_ia'             => ( is => 'ro', lazy => 1, builder => 1 );

method _build__schema {
  # TODO: Build a proper config here
  return App::KSP_CKAN::Crawler::Schema->connect(
    "dbi:mysql:dbname=ksp_ckan",
    $ENV{'CKAN_DBUSER'}, 
    $ENV{'CKAN_DBPASS'},
  );
}

method _build__CKAN_meta {
  return App::KSP_CKAN::Tools::Git->new(
    remote  => $self->config->CKAN_meta,
    local   => $self->config->working,
    clean   => 1,
  );
}

method _build__inflator {
  return App::KSP_CKAN::Crawler::InflateNetKAN->new(
    config  => $self->config,
  );
}

method _build__ia {
  return App::KSP_CKAN::Tools::IA->new(
    config  => $self->config,
  );
}

method _build__CKAN_meta_path {
  return $self->config->working."/".$self->_CKAN_meta->working;
};

method update_ckan_meta {
  $self->_CKAN_meta->pull;
  my $path = $self->_CKAN_meta_path;
  my @dirs = grep { -d $path."/$_" } read_dir($path);
  $self->debug("Updating DB");
  foreach my $dir (@dirs) {
    my @ckans = File::Find::Rule->file()->name( qr/\.ckan$/ )->in( "$path/$dir" );
    foreach my $ckan (@ckans) {
      my $file = basename($ckan);
      my $result = $self->_schema->resultset('CKAN_meta')->find_or_create({
        identifier  => $dir,
        file        => $file
      });
    }
  }
}

method check_existing {
  my $path = $self->_CKAN_meta_path;
  my $ckans = $self->_schema->resultset('CKAN_meta')->search;
  $self->debug("Checking for file existence");
  while (my $ckan = $ckans->next) {
    if ( -e $path."/".$ckan->identifier."/".$ckan->file ) {
      $ckan->update( { deleted => 0 } );
    } else {
      $ckan->update( { deleted => 1 } );
    }
  }
}

method update_random_ckans($number = 20) {
  my $path = $self->_CKAN_meta_path;
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => 0 });
  # TODO: This may never finish need to use last_checked
  $self->debug("Checking random ckans");
  foreach my $row (@rows) {
    $self->debug("Updating: ".$row->file);
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $path."/".$row->identifier."/".$row->file );
    $row->update( {
      download_sha1 => $ckan->download_sha1,
    } );
  }
}

method check_random_mirrored($number = 20) {
  my $path = $self->_CKAN_meta_path;
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => { '!=', 0 }, mirrored => 0 });
  $self->debug("Checking random mirrored ckans");
  foreach my $row (@rows) {
    my $ckan = App::KSP_CKAN::Metadata::Ckan->new( file => $path."/".$row->identifier."/".$row->file );
    $self->debug("Checking ".$ckan->mirror_item." - SHA1: ".$ckan->download_sha1) if $ckan->can_mirror;
    $row->update( {
      last_checked => \'NOW()',
      mirrored    => $self->_ia->ckan_mirrored( ckan => $ckan),
    } ) if $ckan->can_mirror;
    sleep 5; # We're crawling, lets not hit the mirror too hard.
  }
}

method inflate_random($number = 5) {
  # TODO: This will inflate things that don't need inflating
  my @rows  = $self->_schema->resultset('CKAN_meta')->rand($number)->search({ deleted => 0, download_sha1 => 0 });
  my $path = $self->_CKAN_meta_path;
  $self->_CKAN_meta->pull;
  
  my $tmp = File::Temp::tempdir();
  my @files;
  $self->debug("Inflating random ckans");
  foreach my $row (@rows) {
    my $file = $row->identifier.".netkan";
    my $output = $tmp."/$file";
    copy($path."/".$row->identifier."/".$row->file, $output);
    push(@files, $output);
  }
  $self->_inflator->inflate(\@files);
  remove_tree($tmp);
}

method run {
  my $update_ckan_meta  = AE::timer 0, 3600, sub { $self->update_ckan_meta; };
  my $check_existing    = AE::timer 600, 3600, sub { $self->check_existing; };
  my $update_random     = AE::timer 30, 300, sub { $self->update_random_ckans; };
  my $check_random      = AE::timer 30, 300, sub { $self->check_random_mirrored; };
  my $inflate_random    = AE::timer 60, 600, sub { $self->inflate_random; };
  EV::loop; 
}

with('App::KSP_CKAN::Roles::Logger');

1;
